### **物品翻译功能技术方案 (v1.0)**

#### 1. 概述 (Overview)

本文档旨在为 `Translate_AllinOne` 模组的**物品翻译**功能提供清晰、高效、可行的技术实现方案。

核心目标是在不牺牲用户体验的前提下，以**经济高效**的方式实现游戏内物品的实时翻译。我们将采用客户端实时修改与模板化相结合的策略，确保翻译的即时性、准确性，并最大限度地降低对大语言模型（LLM）的API调用成本。

#### 2. 核心技术选型 (Core Technology Choices)

我们选择**方案二：实时修改 `ItemStack` 的 `getTooltip()` 方法**。

*   **入口点 (Entry Point):** 通过 Mixin 注入 `net.minecraft.item.ItemStack` 的 `getTooltip()` 方法。此方法在玩家鼠标悬停于物品上时会**每帧调用**，为我们提供了完美的实时UI更新入口。
*   **放弃原因:** 我们放弃了拦截网络数据包的方案，因为它存在致命的用户体验缺陷（翻译结果延迟、需要用户二次操作才能刷新），且实现刷新逻辑的复杂度远高于预期。

#### 3. 系统组件设计 (System Component Design)

为了实现该功能，我们将设计以下几个核心组件：

| 组件 | 类型 | 职责 |
| :--- | :--- | :--- |
| `ItemTranslateManager` | 单例 (Singleton) | **总控制器**。负责接收翻译请求，管理翻译状态（待翻译、翻译中、已翻译），协调其他组件工作，并作为缓存的唯一入口。 |
| `LoreTemplateProcessor` | 静态工具类 | **模板处理器**。负责将带有动态数值的文本行转换为通用模板，并在翻译后将数值重新应用回去。 |
| `ItemStackMixin` | Mixin 类 | **注入点**。负责拦截 `getTooltip()` 方法，遍历每一行Lore，并调用 `ItemTranslateManager` 获取用于显示的文本。 |
| `ItemCacheProvider` | 数据存储类 | **缓存提供者**。提供一个线程安全的、持久化的键值对缓存，用于存储模板的翻译结果。 |

#### 4. 工作流程 (Workflow)

以下是用户将鼠标悬停到一个未翻译物品上时的完整工作流程：

1.  **触发:** 玩家鼠标悬停在某物品上，`ItemStack.getTooltip()` 被调用。
2.  **拦截:** `ItemStackMixin` 捕获该调用，并获取原始的 `Tooltip` 文本列表（`List<Text>`）。
3.  **迭代处理:** Mixin 遍历列表中的每一行文本 (`loreLine`)。对每一行，它都调用 `ItemTranslateManager.getTranslatedLine(loreLine)`。
4.  **管理器处理:** `ItemTranslateManager` 接收到 `loreLine` 后：
    a.  首先查询 **缓存**。
    b.  **[缓存命中 - 已翻译]:** 如果缓存中存在该行的翻译结果，直接返回已翻译的 `Text` 对象。流程结束。
    c.  **[缓存命中 - 翻译中]:** 如果缓存中该行正处于“翻译中”状态，返回一个带有加载动画的 `Text` 对象（例如 `Text.literal("翻译中...")`）。流程结束。
    d.  **[缓存未命中]:** 这是最关键的首次翻译流程：
        i.  调用 `LoreTemplateProcessor.extract(loreLine.getString())`，将文本转换为模板。
            *   **示例:** 输入 `"伤害: +7.5 (每秒)"`，输出 `TemplateResult("伤害: +{d1} (每秒)", [7.5])`。
        ii. 将该**模板**作为Key，存入缓存，并标记其状态为 **“翻译中”**。
        iii. **异步**启动一个翻译任务，将模板文本发送给LLM进行翻译。
        iv.  在**当前帧**，向 `ItemStackMixin` 返回一个带有加载动画的 `Text` 对象。
5.  **异步翻译完成:**
    a.  后台线程收到LLM的翻译结果，例如 `"Damage: +{d1} (per second)"`。
    b.  `ItemTranslateManager` 更新缓存，将该模板的状态更新为 **“已翻译”**，并存储翻译结果。
6.  **UI 自动更新:**
    a.  由于玩家鼠标仍在悬停，`getTooltip()` 在下一帧或几帧后再次被调用。
    b.  流程重复，但这次当 `ItemTranslateManager` 查询缓存时，会直接命中**步骤 4.b**，找到已翻译的模板。
    c.  调用 `LoreTemplateProcessor.reassemble("Damage: +{d1} (per second)", [7.5])`，将动态数值重新组合进去，得到最终的文本 `"Damage: +7.5 (per second)"`。
    d.  返回最终的 `Text` 对象，UI上无缝地从“翻译中...”更新为最终译文。

#### 5. 数据模型 (Data Models)

为了清晰地管理数据，我们会定义以下数据结构：

```java
// 用于模板处理器返回的结果
public class TemplateExtractionResult {
    public final String template; // e.g., "伤害: +{d1}"
    public final List<Object> values; // e.g., [7.5]
}

// 用于缓存提供者存储的条目
public class CacheEntry {
    public enum Status { PENDING, TRANSLATED, FAILED }
    public final Status status;
    public final String translatedTemplate; // 翻译后的模板
}
```

#### 6. 实现步骤建议 (Suggested Implementation Steps)

1.  **创建 `LoreTemplateProcessor.java`:**
    *   实现 `extract()` 方法。使用正则表达式识别整数、小数、千位分隔符数字（如 `1,000,000`）。
    *   实现 `reassemble()` 方法，使用 `String.format` 或类似的机制将数值插回翻译好的模板。
2.  **创建 `ItemCacheProvider.java`:**
    *   内部使用 `ConcurrentHashMap<String, CacheEntry>` 确保线程安全。
    *   可以考虑实现简单的JSON文件读写，实现缓存的持久化。
3.  **创建 `ItemTranslateManager.java`:**
    *   实现 `getTranslatedLine()` 的核心逻辑。
    *   管理后台翻译的线程池 (`ExecutorService`)。
4.  **创建 `ItemStackMixin.java`:**
    *   使用 `@Inject(method = "getTooltip", at = @At("RETURN"), cancellable = true)` 来注入逻辑。
    *   在方法内部获取并修改 `List<Text>`。
5.  **集成与测试:**
    *   在配置界面中添物品翻译的开关。
    *   编写单元测试，尤其是针对 `LoreTemplateProcessor` 的各种边界情况。
    *   进行游戏内测试，验证不同类型物品的翻译效果和性能。

#### 7. 关键考量与优化 (Key Considerations)

*   **性能:** 模板化和缓存机制确保了`getTooltip()`中的主要计算只在首次遇到新物品时发生，后续调用开销极低。
*   **线程安全:** `ItemTranslateManager` 和 `ItemCacheProvider` 的所有写操作都必须是线程安全的。
*   **无数字文本:** `LoreTemplateProcessor` 必须能优雅地处理不含任何动态数字的文本行（此时模板即原文）。
*   **样式保留:** 可以复用 `StylePreserver` 的思想，在模板化之前提取文本样式，在重组之后再应用回去，以支持带颜色的 Lore 文本。
